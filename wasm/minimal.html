<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <title>rgb2oklch wasm 最小示例</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, Helvetica, Arial,
          sans-serif;
        padding: 16px;
      }

      label {
        display: inline-block;
        width: 24px;
      }

      input[type="number"] {
        width: 80px;
      }

      .row {
        margin: 8px 0;
      }

      pre {
        background: #111;
        color: #eee;
        padding: 12px;
        border-radius: 6px;
      }

      button {
        padding: 6px 12px;
      }
    </style>
  </head>

  <body>
    <h2>rgb2oklch (纯 JS + Wasm, 无胶水)</h2>
    <div class="row">
      <label for="r">R</label>
      <input id="r" type="number" min="0" max="255" value="255" />
      <label for="g">G</label>
      <input id="g" type="number" min="0" max="255" value="0" />
      <label for="b">B</label>
      <input id="b" type="number" min="0" max="255" value="0" />
      <button id="run">转换</button>
    </div>
    <pre id="out">加载中...</pre>

    <h2 style="margin-top: 24px">oklch2rgb (纯 JS + Wasm, 无胶水)</h2>
    <div class="row">
      <label for="l">L</label>
      <input
        id="l"
        type="number"
        min="0"
        max="1"
        step="0.000001"
        value="0.62796"
      />
      <label for="c">C</label>
      <input id="c" type="number" min="0" step="0.000001" value="0.25754" />
      <label for="h">h</label>
      <input
        id="h"
        type="number"
        min="0"
        max="360"
        step="0.000001"
        value="29.23388"
      />
      <label for="rel" title="relative chroma (0..1)">rel</label>
      <input
        id="rel"
        type="number"
        min="0"
        max="1"
        step="0.000001"
        placeholder="(可选)"
      />
      <button id="run2">转换</button>
    </div>
    <pre id="out2">加载中...</pre>

    <script>
      // 纯原生加载 .wasm（不使用 Emscripten 生成的 JS）
      // 需要浏览器通过 HTTP(S) 提供正确的 MIME: application/wasm
      // 若 .wasm 是 WASI 构建，提供最小 wasi_snapshot_preview1 stub 以便在浏览器中实例化。
      let rgb2oklchExports, rgb2oklchMemory;
      let oklch2rgbExports, oklch2rgbMemory;
      let extractExports, extractMemory;

      // ---- 最小 WASI stub 与带回退的实例化工具 ----
      function createWasiStub(memory) {
        const encoder = new TextEncoder();
        // 简易写入：忽略内容，仅报告写入 0 字节，避免报错
        function fd_write(fd, iov, iovcnt, pOut) {
          try {
            const view = new DataView(memory.buffer);
            view.setUint32(pOut >>> 0, 0, true);
          } catch (_) {}
          return 0; // __WASI_ERRNO_SUCCESS
        }
        function ret0() {
          return 0;
        }
        function enosys() {
          return 52; // __WASI_ERRNO_ENOSYS
        }
        function proc_exit(code) {
          // 将 WASI 退出转为异常，避免整个页面崩溃
          throw new Error("WASI proc_exit: " + code);
        }
        return {
          args_get: ret0,
          args_sizes_get: function (pArgc, pArgvBufSize) {
            try {
              const view = new DataView(memory.buffer);
              view.setUint32(pArgc >>> 0, 0, true);
              view.setUint32(pArgvBufSize >>> 0, 0, true);
            } catch (_) {}
            return 0;
          },
          environ_get: ret0,
          environ_sizes_get: function (pCount, pBufSize) {
            try {
              const view = new DataView(memory.buffer);
              view.setUint32(pCount >>> 0, 0, true);
              view.setUint32(pBufSize >>> 0, 0, true);
            } catch (_) {}
            return 0;
          },
          fd_write,
          fd_close: ret0,
          fd_read: enosys,
          fd_seek: enosys,
          fd_fdstat_get: ret0,
          fd_fdstat_set_flags: ret0,
          fd_sync: ret0,
          fd_prestat_get: enosys,
          fd_prestat_dir_name: enosys,
          path_open: enosys,
          path_unlink_file: enosys,
          path_create_directory: enosys,
          path_remove_directory: enosys,
          path_readlink: enosys,
          path_filestat_get: enosys,
          fd_filestat_get: enosys,
          poll_oneoff: enosys,
          clock_time_get: ret0,
          random_get: function (ptr, len) {
            try {
              const dst = new Uint8Array(memory.buffer, ptr >>> 0, len >>> 0);
              crypto.getRandomValues(dst);
            } catch (_) {}
            return 0;
          },
          proc_exit,
        };
      }

      async function instantiateWasmWithFallback(url) {
        // 先尝试无需 imports 的实例化（适用于独立 wasm）
        try {
          const resp = await fetch(url);
          const source = resp.headers
            .get("content-type")
            ?.includes("application/wasm")
            ? WebAssembly.instantiateStreaming(fetch(url), {})
            : WebAssembly.instantiate(await resp.arrayBuffer(), {});
          return (await source).instance;
        } catch (e1) {
          // 回退：提供最小 WASI 与 env/imports
          const buf = await (await fetch(url)).arrayBuffer();
          // 预创建一块内存以备某些模块需要 env.memory 导入
          const memory = new WebAssembly.Memory({
            initial: 256,
            maximum: 16384,
          });
          const imports = {
            wasi_snapshot_preview1: createWasiStub(memory),
            env: {
              memory,
              abort: function () {},
              emscripten_notify_memory_growth: function () {},
            },
          };
          const { instance } = await WebAssembly.instantiate(buf, imports);
          return instance;
        }
      }

      async function loadRgb2OklchWasm() {
        try {
          const instance = await instantiateWasmWithFallback("rgb2oklch.wasm");
          rgb2oklchExports = instance.exports;
          rgb2oklchMemory = rgb2oklchExports.memory; // WebAssembly.Memory
          document.getElementById("out").textContent = "WASM 已加载";
        } catch (e) {
          document.getElementById("out").textContent = "加载 WASM 失败: " + e;
          console.error(e);
        }
      }

      async function loadOklch2RgbWasm() {
        try {
          const instance = await instantiateWasmWithFallback("oklch2rgb.wasm");
          oklch2rgbExports = instance.exports;
          oklch2rgbMemory = oklch2rgbExports.memory;
          document.getElementById("out2").textContent = "WASM 已加载";
        } catch (e) {
          document.getElementById("out2").textContent = "加载 WASM 失败: " + e;
          console.error(e);
        }
      }

      function rgb2oklch(r, g, b) {
        if (!rgb2oklchExports) {
          return "WASM 未就绪";
        }
        // 调用导出的 rgb2oklch_calc_js(r,g,b) -> 返回指向 3 个 double 的指针
        const ptr =
          rgb2oklchExports.rgb2oklch_calc_js(r | 0, g | 0, b | 0) >>> 0;
        const f64 = new Float64Array(rgb2oklchMemory.buffer, ptr, 3);
        let L = f64[0];
        let C = f64[1];
        let h = f64[2];
        // 与 C 程序一致的展示：6 位小数，去尾零，C≈0 时强制 h=0
        const tiny = 1e-15;
        const fmt = (x) => {
          if (Math.abs(x) < tiny) x = 0;
          let s = x.toFixed(6);
          // 去掉多余的 0 和小数点
          s = s.replace(/\.0+$/, "").replace(/(\.[0-9]*?)0+$/, "$1");
          return s;
        };
        if (Math.abs(C) < tiny) {
          C = 0;
          h = 0;
        }
        return `L ${fmt(L)}  C ${fmt(C)}  h ${fmt(h)}`;
      }

      document.getElementById("run").addEventListener("click", () => {
        const r = +document.getElementById("r").value;
        const g = +document.getElementById("g").value;
        const b = +document.getElementById("b").value;
        document.getElementById("out").textContent = rgb2oklch(r, g, b);
      });

      function oklch2rgb(L, C, h, rel) {
        if (!oklch2rgbExports) {
          return "WASM 未就绪";
        }
        // 如果提供了 rel（数字且在 [0,1]），则走相对色度导出；否则使用绝对 C 导出
        let ptr;
        if (Number.isFinite(rel)) {
          const r = Math.max(0, Math.min(1, rel));
          ptr = oklch2rgbExports.oklch2rgb_calc_rel_js(L, h, r) >>> 0;
        } else {
          ptr = oklch2rgbExports.oklch2rgb_calc_js(L, C, h) >>> 0;
        }
        const i32 = new Int32Array(oklch2rgbMemory.buffer, ptr, 3);
        const R = i32[0] | 0;
        const G = i32[1] | 0;
        const B = i32[2] | 0;
        return `R ${R}  G ${G}  B ${B}`;
      }

      document.getElementById("run2").addEventListener("click", () => {
        const L = +document.getElementById("l").value;
        const C = +document.getElementById("c").value;
        const H = +document.getElementById("h").value;
        const REL_RAW = document.getElementById("rel").value;
        const rel = REL_RAW === "" ? undefined : +REL_RAW;
        document.getElementById("out2").textContent = oklch2rgb(L, C, H, rel);
      });

      loadRgb2OklchWasm();
      loadOklch2RgbWasm();
    </script>

    <h2 style="margin-top: 24px">
      extract-colors（图片取色，纯 JS + Wasm, 无胶水）
    </h2>
    <div class="row">
      <input id="file" type="file" accept="image/*" />
      <button id="draw-demo">绘制示例图</button>
      <button id="extract">提取颜色</button>
    </div>
    <div
      class="row"
      style="display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap"
    >
      <div>
        <canvas
          id="canvas"
          style="max-width: 360px; border: 1px solid #ccc"
        ></canvas>
        <div style="font-size: 12px; color: #666; margin-top: 4px">
          预览（将按需子采样，默认像素预算 64000）
        </div>
      </div>
      <div style="min-width: 280px; flex: 1">
        <div
          id="swatches"
          style="display: flex; flex-wrap: wrap; gap: 8px"
        ></div>
        <pre id="extract-out" style="margin-top: 12px">加载中...</pre>
      </div>
    </div>

    <script>
      // 加载 extract-colors.wasm
      async function loadExtractColorsWasm() {
        try {
          const instance = await instantiateWasmWithFallback(
            "extract-colors.wasm"
          );
          extractExports = instance.exports;
          extractMemory = extractExports.memory;
          document.getElementById("extract-out").textContent = "WASM 已加载";
        } catch (e) {
          document.getElementById("extract-out").textContent =
            "加载 WASM 失败: " + e;
          console.error(e);
        }
      }

      // 将图片绘制到 canvas 并返回 ImageData
      function getImageDataFromImage(img) {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        const maxW = 1024; // 预览缩放上限，算法内部仍会子采样
        const scale = Math.min(1, maxW / img.naturalWidth);
        const w = Math.max(1, Math.round(img.naturalWidth * scale));
        const h = Math.max(1, Math.round(img.naturalHeight * scale));
        canvas.width = w;
        canvas.height = h;
        ctx.clearRect(0, 0, w, h);
        ctx.drawImage(img, 0, 0, w, h);
        return ctx.getImageData(0, 0, w, h);
      }

      // 将文件读取为 Image 对象
      function loadFileToImage(file) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            URL.revokeObjectURL(url);
            resolve(img);
          };
          img.onerror = reject;
          img.src = url;
        });
      }

      // 在 canvas 上绘制一张程序化示例图（色块+渐变）
      function drawProgrammaticDemo() {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const w = 480,
          h = 320;
        canvas.width = w;
        canvas.height = h;
        // 背景渐变
        const g = ctx.createLinearGradient(0, 0, w, 0);
        g.addColorStop(0, "#ff6b6b");
        g.addColorStop(0.33, "#feca57");
        g.addColorStop(0.66, "#1dd1a1");
        g.addColorStop(1, "#54a0ff");
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, w, h);
        // 前景色块
        const colors = ["#222", "#fff", "#8e44ad", "#16a085", "#d35400"];
        const cw = 80,
          ch = 60,
          pad = 12;
        colors.forEach((c, i) => {
          const x = pad + (i % 5) * (cw + pad);
          const y = h - ch - pad;
          ctx.fillStyle = c;
          ctx.fillRect(x, y, cw, ch);
          ctx.strokeStyle = "rgba(0,0,0,.2)";
          ctx.strokeRect(x + 0.5, y + 0.5, cw - 1, ch - 1);
        });
        return ctx.getImageData(0, 0, w, h);
      }

      // 调用 wasm 提取颜色
      function extractColorsFromImageData(imageData, opts = {}) {
        if (!extractExports) throw new Error("WASM 未就绪");
        const { width, height, data } = imageData;
        const len = data.byteLength >>> 0;
        // 申请/获取 wasm 像素缓冲区
        const ptr = extractExports.get_pixels_buffer(len) >>> 0;
        if (!ptr) throw new Error("get_pixels_buffer 失败");
        // 将 RGBA 写入 wasm 线性内存
        const heapU8 = new Uint8Array(extractMemory.buffer, ptr, len);
        heapU8.set(data);

        // 选项（与 C 默认一致）
        const pixels = opts.pixels ?? 64000;
        const distance = opts.distance ?? 0.22;
        const satDist = opts.saturationDistance ?? 0.2;
        const lightDist = opts.lightnessDistance ?? 0.2;
        const hueDist = opts.hueDistance ?? 1 / 12; // ~30°
        const alphaThreshold = opts.alphaThreshold ?? 250;
        const maxColors = opts.maxColors ?? 16;

        // 调用 wasm
        const outPtr =
          extractExports.extract_colors_from_rgba_js(
            ptr,
            width | 0,
            height | 0,
            pixels | 0,
            +distance,
            +satDist,
            +lightDist,
            +hueDist,
            alphaThreshold | 0,
            maxColors | 0
          ) >>> 0;
        if (!outPtr) throw new Error("extract_colors_from_rgba_js 失败");

        // 读取结果缓冲（double）
        const f64 = new Float64Array(extractMemory.buffer, outPtr, 1 + 8 * 64);
        const m = Math.max(0, Math.min(64, Math.floor(f64[0])));
        const colors = [];
        for (let i = 0; i < m; i++) {
          const base = 1 + i * 8;
          const R = Math.round(f64[base + 0]);
          const G = Math.round(f64[base + 1]);
          const B = Math.round(f64[base + 2]);
          const hue = f64[base + 3];
          const intensity = f64[base + 4];
          const lightness = f64[base + 5];
          const saturation = f64[base + 6];
          const area = f64[base + 7];
          const hex = `#${[R, G, B]
            .map((v) => v.toString(16).padStart(2, "0"))
            .join("")}`;
          colors.push({
            R,
            G,
            B,
            hex,
            hue,
            intensity,
            lightness,
            saturation,
            area,
          });
        }
        return { width, height, colors };
      }

      function renderSwatches(result) {
        const sw = document.getElementById("swatches");
        const out = document.getElementById("extract-out");
        sw.innerHTML = "";
        const fmt = (x) => {
          if (!Number.isFinite(x)) return "0";
          let s = x
            .toFixed(6)
            .replace(/\.0+$/, "")
            .replace(/(\.[0-9]*?)0+$/, "$1");
          return s;
        };
        result.colors.forEach((c) => {
          const chip = document.createElement("div");
          chip.style.width = "48px";
          chip.style.height = "48px";
          chip.style.borderRadius = "6px";
          chip.style.border = "1px solid #ccc";
          chip.style.background = c.hex;
          chip.title = `${c.hex}\narea ${fmt(c.area)}`;
          sw.appendChild(chip);
        });
        out.textContent = JSON.stringify(result.colors, null, 2);
      }

      // 交互：文件选择、示例图、提取按钮
      document.getElementById("file").addEventListener("change", async (e) => {
        const f = e.target.files?.[0];
        if (!f) return;
        const img = await loadFileToImage(f);
        const id = getImageDataFromImage(img);
        document.getElementById(
          "extract-out"
        ).textContent = `图像 ${id.width}×${id.height}`;
      });

      document.getElementById("draw-demo").addEventListener("click", () => {
        const id = drawProgrammaticDemo();
        document.getElementById(
          "extract-out"
        ).textContent = `图像 ${id.width}×${id.height}`;
      });

      document.getElementById("extract").addEventListener("click", () => {
        try {
          const canvas = document.getElementById("canvas");
          if (!(canvas.width && canvas.height)) {
            document.getElementById("extract-out").textContent =
              "请先选择图片或点击“从示例图提取”";
            return;
          }
          const ctx = canvas.getContext("2d");
          const id = ctx.getImageData(0, 0, canvas.width, canvas.height);
          const result = extractColorsFromImageData(id);
          renderSwatches(result);
        } catch (e) {
          document.getElementById("extract-out").textContent = "提取失败: " + e;
          console.error(e);
        }
      });

      loadExtractColorsWasm();
    </script>
  </body>
</html>
