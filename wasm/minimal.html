<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <title>颜色转换与图片取色</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, Helvetica, Arial,
          sans-serif;
        padding: 16px;
      }

      label {
        display: inline-block;
        width: 24px;
      }

      input[type="number"] {
        width: 80px;
      }

      .row {
        margin: 8px 0;
      }

      pre {
        background: #111;
        color: #eee;
        padding: 12px;
        border-radius: 6px;
      }

      button {
        padding: 6px 12px;
      }
      .chip {
        display: inline-block;
        width: 24px;
        height: 24px;
        border: 1px solid #ccc;
        border-radius: 4px;
        vertical-align: middle;
        margin-right: 8px;
      }
      /* 入参变化高亮 */
      .animating {
        outline: 2px solid #f90;
        outline-offset: 2px;
        transition: outline-color 120ms ease;
      }
    </style>
  </head>

  <body>
    <h2>rgb2oklch</h2>
    <div class="row">
      <label for="r">R</label>
      <input id="r" type="number" min="0" max="255" value="255" />
      <label for="g">G</label>
      <input id="g" type="number" min="0" max="255" value="0" />
      <label for="b">B</label>
      <input id="b" type="number" min="0" max="255" value="0" />
    </div>
    <div class="row">
      <span
        id="chip-oklch"
        class="chip"
        title="oklch(...)"
        aria-label="OKLCH 颜色"
      ></span>
      <pre id="out" style="display: inline-block; margin: 0">加载中...</pre>
    </div>

    <h2 style="margin-top: 24px">oklch2rgb</h2>
    <div class="row">
      <label for="l">L</label>
      <input
        id="l"
        type="number"
        min="0"
        max="1"
        step="0.000001"
        value="0.62796"
      />
      <label for="c">C</label>
      <input id="c" type="number" min="0" step="0.000001" value="0.25754" />
      <label for="h">h</label>
      <input
        id="h"
        type="number"
        min="0"
        max="360"
        step="0.000001"
        value="29.23388"
      />
      <label for="rel" title="relative chroma (0..1)">rel</label>
      <input
        id="rel"
        type="number"
        min="0"
        max="1"
        step="0.000001"
        placeholder="(可选)"
      />
    </div>
    <div class="row">
      <span
        id="chip-rgb"
        class="chip"
        title="rgb(...)"
        aria-label="RGB 颜色"
      ></span>
      <pre id="out2" style="display: inline-block; margin: 0">加载中...</pre>
    </div>

    <script type="module">
      import {
        rgb2oklch as roFn,
        oklch2rgb_abs,
        oklch2rgb_rel,
      } from "./color-convert.js";

      // color-convert.js 内部会自动初始化，无需在此显式调用。
      // 初始提示文案：
      document.getElementById("out").textContent = "计算中...";
      document.getElementById("out2").textContent = "计算中...";

      function fmtNum(x) {
        let v = x;
        if (Math.abs(v) < 1e-15) v = 0;
        let s = v
          .toFixed(6)
          .replace(/\.0+$/, "")
          .replace(/(\.[0-9]*?)0+$/, "$1");
        return s;
      }
      function fmtPct01(x) {
        const n = Number(x);
        if (!Number.isFinite(n)) return "0%";
        return (
          (n * 100)
            .toFixed(2)
            .replace(/\.0+$/, "")
            .replace(/(\.[0-9]*?)0+$/, "$1") + "%"
        );
      }

      async function updateRgb2Oklch() {
        try {
          const r = +document.getElementById("r").value;
          const g = +document.getElementById("g").value;
          const b = +document.getElementById("b").value;
          const { L, C, h } = await roFn(r, g, b);
          const _C = Math.abs(C) < 1e-15 ? 0 : C;
          const _h = _C === 0 ? 0 : h;
          document.getElementById("out").textContent = `L ${fmtNum(
            L
          )}  C ${fmtNum(_C)}  h ${fmtNum(_h)}`;
          // Show OKLCH via CSS color function
          const chip = document.getElementById("chip-oklch");
          const cssColor = `oklch(${fmtPct01(L)} ${fmtNum(_C)} ${fmtNum(
            _h
          )}deg)`;
          chip.style.background = cssColor;
          chip.title = cssColor;
        } catch (e) {
          document.getElementById("out").textContent = "运行失败：" + e;
          console.error(e);
        }
      }
      // 输入框 onchange 触发更新
      ["r", "g", "b"].forEach((id) =>
        document.getElementById(id).addEventListener("change", updateRgb2Oklch)
      );

      async function updateOklch2Rgb() {
        try {
          const L = +document.getElementById("l").value;
          const C = +document.getElementById("c").value;
          const H = +document.getElementById("h").value;
          const REL_RAW = document.getElementById("rel").value;
          const rel = REL_RAW === "" ? undefined : +REL_RAW;
          const rgb = Number.isFinite(rel)
            ? await oklch2rgb_rel(L, H, rel)
            : await oklch2rgb_abs(L, C, H);
          document.getElementById(
            "out2"
          ).textContent = `R ${rgb.R}  G ${rgb.G}  B ${rgb.B}`;
          // Show RGB via CSS color function
          const chip = document.getElementById("chip-rgb");
          const cssColor = `rgb(${rgb.R}, ${rgb.G}, ${rgb.B})`;
          chip.style.background = cssColor;
          chip.title = cssColor;
        } catch (e) {
          document.getElementById("out2").textContent = "运行失败：" + e;
          console.error(e);
        }
      }
      // 输入框 onchange 触发更新
      ["l", "c", "h", "rel"].forEach((id) =>
        document.getElementById(id).addEventListener("change", updateOklch2Rgb)
      );

      // 初次自动计算一次
      (async () => {
        await Promise.all([updateRgb2Oklch(), updateOklch2Rgb()]);
      })();
    </script>

    <h2 style="margin-top: 24px">extract-colors</h2>
    <div class="row">
      <input id="file" type="file" accept="image/*" />
      <button id="extract">提取颜色</button>
    </div>
    <div
      class="row"
      style="display: flex; gap: 16px; align-items: flex-start; flex-wrap: wrap"
    >
      <div>
        <img
          id="preview"
          style="max-width: 360px; border: 1px solid #ccc; display: block"
        />
        <div style="font-size: 12px; color: #666; margin-top: 4px">
          预览（抽样与缩放由模块内部共享 Canvas 完成）
        </div>
      </div>
      <div style="min-width: 280px; flex: 1">
        <div
          id="swatches"
          style="display: flex; flex-wrap: wrap; gap: 8px"
        ></div>
        <pre id="extract-out" style="margin-top: 12px">加载中...</pre>
      </div>
    </div>

    <script type="module">
      import extractColors from "./extract-colors.js";

      // 初始提示
      document.getElementById("extract-out").textContent = "请选择图片";

      function renderSwatches(colors, elapsedMs) {
        const sw = document.getElementById("swatches");
        const out = document.getElementById("extract-out");
        sw.innerHTML = "";
        const fmt = (x) => {
          if (!Number.isFinite(x)) return "0";
          let s = x
            .toFixed(6)
            .replace(/\.0+$/, "")
            .replace(/(\.[0-9]*?)0+$/, "$1");
          return s;
        };
        const fmtTime = (ms) => {
          if (!Number.isFinite(ms)) return "0 ms";
          if (ms >= 1000) return (ms / 1000).toFixed(2) + " s";
          return Math.round(ms) + " ms";
        };
        // 按占比从高到低排序
        const sorted = [...colors].sort((a, b) => {
          const aa = Number.isFinite(a?.area) ? a.area : 0;
          const bb = Number.isFinite(b?.area) ? b.area : 0;
          return bb - aa;
        });
        sorted.forEach((c) => {
          const chip = document.createElement("div");
          chip.style.width = "48px";
          chip.style.height = "48px";
          chip.style.borderRadius = "6px";
          chip.style.border = "1px solid #ccc";
          chip.style.background = c.hex;
          chip.title = `${c.hex}\narea ${fmt(c.area)}`;
          sw.appendChild(chip);
        });
        const timing =
          elapsedMs != null ? `耗时 ${fmtTime(elapsedMs)}\n\n` : "";
        out.textContent = timing + JSON.stringify(sorted, null, 2);
      }

      // 交互：文件选择 -> 直接走模块内置的共享 Canvas 流程
      let _lastImage = null;
      function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
          const fr = new FileReader();
          fr.onload = () => resolve(fr.result);
          fr.onerror = reject;
          fr.readAsDataURL(file);
        });
      }
      document.getElementById("file").addEventListener("change", async (e) => {
        const f = e.target.files?.[0];
        if (!f) return;
        const dataUrl = await readFileAsDataURL(f);
        _lastImage = await new Promise((resolve, reject) => {
          const im = new Image();
          im.onload = () => resolve(im);
          im.onerror = reject;
          im.src = dataUrl;
        });
        const preview = document.getElementById("preview");
        preview.src = dataUrl;
        document.getElementById(
          "extract-out"
        ).textContent = `已载入：${_lastImage.naturalWidth}×${_lastImage.naturalHeight}`;
      });

      document.getElementById("extract").addEventListener("click", () => {
        if (!_lastImage) {
          document.getElementById("extract-out").textContent = "请先选择图片";
          return;
        }
        const out = document.getElementById("extract-out");
        out.textContent = "提取中...";
        const t0 = performance.now();
        extractColors(_lastImage)
          .then((colors) => {
            const dt = performance.now() - t0;
            renderSwatches(colors, dt);
          })
          .catch((e) => {
            document.getElementById("extract-out").textContent =
              "提取失败: " + e;
            console.error(e);
          });
      });
    </script>
  </body>
  
  <hr />
  <h2 style="margin-top: 24px">squircle-svg (WASM)</h2>
  <div class="row" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap">
    <label for="shape">形状</label>
    <select id="shape">
      <option value="squircle" selected>squircle</option>
      <option value="capsule">capsule</option>
    </select>
    <label for="w2">W</label>
    <input id="w2" type="number" min="1" value="200" />
    <label for="h2">H</label>
    <input id="h2" type="number" min="1" value="120" />
    <label for="r2">R</label>
    <input id="r2" type="number" min="0" value="16" />
    <button id="gen-shape">生成</button>
  <button id="toggle-anim" title="在 200↔400 之间以 300ms 每段往返动画">宽度动画</button>
  </div>
  <div class="row" style="display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap">
    <svg id="svg-demo" width="300" height="220" viewBox="0 0 200 120">
      <path id="svg-path" d="" fill="#09f"></path>
    </svg>
    <pre id="svg-path-text" style="min-width:320px; flex:1; overflow:auto">加载中...</pre>
  </div>

  <script type="module">
    import { getPath } from './squircle-svg.js';

    const $ = (id) => document.getElementById(id);
    const elShape = $('shape');
    const elW = $('w2');
    const elH = $('h2');
    const elR = $('r2');
    const btn = $('gen-shape');
    const svg = $('svg-demo');
    const pathEl = $('svg-path');
    const textEl = $('svg-path-text');

    let isRendering = false;
    async function renderShape(silent = false) {
      try {
        if (!silent) textEl.textContent = '生成中...';
        if (isRendering) return; // 防止并发渲染
        isRendering = true;
        const shape = elShape.value;
        const w = Math.max(1, +elW.value);
        const h = Math.max(1, +elH.value);
        const r = Math.max(0, +elR.value);
        const d = await getPath(shape, w, h, r);
  svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
  // 同步显示尺寸，便于直观看到宽/高变化
  svg.setAttribute('width', String(w));
  svg.setAttribute('height', String(h));
        pathEl.setAttribute('d', d);
        if (!silent) textEl.textContent = d;
      } catch (e) {
        if (!silent) textEl.textContent = '运行失败：' + e;
        console.error(e);
      } finally {
        isRendering = false;
      }
    }
    btn.addEventListener('click', () => renderShape());
    [elShape, elW, elH, elR].forEach((el) => el.addEventListener('change', () => renderShape()));
    // 初次渲染
    renderShape();

    // 宽度差值动画：在 200 ↔ 400 间往返，单段 300ms（线性）。
    const animBtn = $('toggle-anim');
    const W_MIN = 300;
    const W_MAX = 800;
    const DURATION = 150; // ms per segment
    let animRunning = false;
    let rafId = 0;
    let t0 = 0;

    function loop() {
      if (!animRunning) return;
      const now = performance.now();
      const cycle = ((now - t0) % (DURATION * 2)) / DURATION; // 0..2
      const t = cycle < 1 ? cycle : 2 - cycle; // 往返 0..1..0
      const w = W_MIN + (W_MAX - W_MIN) * t; // 线性插值
      elW.value = Math.max(1, Math.round(w));
      // 静默渲染，避免每帧重写文本
      if (!isRendering) renderShape(true);
      rafId = requestAnimationFrame(loop);
    }

  animBtn.addEventListener('click', () => {
      animRunning = !animRunning;
      animBtn.textContent = animRunning ? '停止动画' : '宽度动画';
      if (animRunning) {
        t0 = performance.now();
    elW.classList.add('animating');
        loop();
      } else if (rafId) {
        cancelAnimationFrame(rafId);
    elW.classList.remove('animating');
      }
    });
  </script>
</html>
</html>
